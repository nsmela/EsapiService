namespace EsapiService.Wrappers
{
    public class AsyncExternalPlanSetup : IExternalPlanSetup
    {
        internal readonly VMS.TPS.Common.Model.API.ExternalPlanSetup _inner;

        // Store the inner ESAPI object reference
        // internal so other wrappers can access it
        // new to override any inherited _inner fields
        internal new readonly IEsapiService _service;

        public AsyncExternalPlanSetup(VMS.TPS.Common.Model.API.ExternalPlanSetup inner, IEsapiService service) : base(inner, service)
        {
            _inner = inner;
            _service = service;

        }

        public ICalculationResult CalculateDoseWithPresetValues(System.Collections.Generic.List<System.Collections.Generic.KeyValuePair<string, VMS.TPS.Common.Model.Types.MetersetValue>> presetValues) => _inner.CalculateDoseWithPresetValues(presetValues) is var result && result is null ? null : new AsyncCalculationResult(result, _service);
        public ICalculationResult CalculateDose() => _inner.CalculateDose() is var result && result is null ? null : new AsyncCalculationResult(result, _service);
        public ICalculationResult CalculatePlanUncertaintyDoses() => _inner.CalculatePlanUncertaintyDoses() is var result && result is null ? null : new AsyncCalculationResult(result, _service);
        public ICalculationResult CalculateLeafMotionsAndDose() => _inner.CalculateLeafMotionsAndDose() is var result && result is null ? null : new AsyncCalculationResult(result, _service);
        public ICalculationResult CalculateLeafMotions() => _inner.CalculateLeafMotions() is var result && result is null ? null : new AsyncCalculationResult(result, _service);
        public ICalculationResult CalculateLeafMotions(VMS.TPS.Common.Model.Types.LMCVOptions options) => _inner.CalculateLeafMotions(options) is var result && result is null ? null : new AsyncCalculationResult(result, _service);
        public ICalculationResult CalculateLeafMotions(VMS.TPS.Common.Model.Types.SmartLMCOptions options) => _inner.CalculateLeafMotions(options) is var result && result is null ? null : new AsyncCalculationResult(result, _service);
        public ICalculationResult CalculateLeafMotions(VMS.TPS.Common.Model.Types.LMCMSSOptions options) => _inner.CalculateLeafMotions(options) is var result && result is null ? null : new AsyncCalculationResult(result, _service);
        public System.Collections.Generic.IReadOnlyList<string> GetModelsForCalculationType(VMS.TPS.Common.Model.Types.CalculationType calculationType) => _inner.GetModelsForCalculationType(calculationType)?.ToList();
        public IOptimizerResult Optimize(int maxIterations) => _inner.Optimize(maxIterations) is var result && result is null ? null : new AsyncOptimizerResult(result, _service);
        public IOptimizerResult Optimize(int maxIterations, VMS.TPS.Common.Model.Types.OptimizationOption optimizationOption) => _inner.Optimize(maxIterations, optimizationOption) is var result && result is null ? null : new AsyncOptimizerResult(result, _service);
        public IOptimizerResult Optimize(int maxIterations, VMS.TPS.Common.Model.Types.OptimizationOption optimizationOption, string mlcId) => _inner.Optimize(maxIterations, optimizationOption, mlcId) is var result && result is null ? null : new AsyncOptimizerResult(result, _service);
        public IOptimizerResult Optimize() => _inner.Optimize() is var result && result is null ? null : new AsyncOptimizerResult(result, _service);
        public IOptimizerResult Optimize(VMS.TPS.Common.Model.Types.OptimizationOptionsIMRT options) => _inner.Optimize(options) is var result && result is null ? null : new AsyncOptimizerResult(result, _service);
        public IOptimizerResult OptimizeVMAT(string mlcId) => _inner.OptimizeVMAT(mlcId) is var result && result is null ? null : new AsyncOptimizerResult(result, _service);
        public IOptimizerResult OptimizeVMAT() => _inner.OptimizeVMAT() is var result && result is null ? null : new AsyncOptimizerResult(result, _service);
        public IOptimizerResult OptimizeVMAT(VMS.TPS.Common.Model.Types.OptimizationOptionsVMAT options) => _inner.OptimizeVMAT(options) is var result && result is null ? null : new AsyncOptimizerResult(result, _service);
        public ICalculationResult CalculateDVHEstimates(string modelId, System.Collections.Generic.Dictionary<string, VMS.TPS.Common.Model.Types.DoseValue> targetDoseLevels, System.Collections.Generic.Dictionary<string, string> structureMatches) => _inner.CalculateDVHEstimates(modelId, targetDoseLevels, structureMatches) is var result && result is null ? null : new AsyncCalculationResult(result, _service);
        public void WriteXml(System.Xml.XmlWriter writer) => _inner.WriteXml(writer);
        public IBeam AddArcBeam(VMS.TPS.Common.Model.Types.ExternalBeamMachineParameters machineParameters, VMS.TPS.Common.Model.Types.VRect<double> jawPositions, double collimatorAngle, double gantryAngle, double gantryStop, VMS.TPS.Common.Model.Types.GantryDirection gantryDirection, double patientSupportAngle, VMS.TPS.Common.Model.Types.VVector isocenter) => _inner.AddArcBeam(machineParameters, jawPositions, collimatorAngle, gantryAngle, gantryStop, gantryDirection, patientSupportAngle, isocenter) is var result && result is null ? null : new AsyncBeam(result, _service);
        public IBeam AddConformalArcBeam(VMS.TPS.Common.Model.Types.ExternalBeamMachineParameters machineParameters, double collimatorAngle, int controlPointCount, double gantryAngle, double gantryStop, VMS.TPS.Common.Model.Types.GantryDirection gantryDirection, double patientSupportAngle, VMS.TPS.Common.Model.Types.VVector isocenter) => _inner.AddConformalArcBeam(machineParameters, collimatorAngle, controlPointCount, gantryAngle, gantryStop, gantryDirection, patientSupportAngle, isocenter) is var result && result is null ? null : new AsyncBeam(result, _service);
        public IBeam AddFixedSequenceBeam(VMS.TPS.Common.Model.Types.ExternalBeamMachineParameters machineParameters, double collimatorAngle, double gantryAngle, VMS.TPS.Common.Model.Types.VVector isocenter) => _inner.AddFixedSequenceBeam(machineParameters, collimatorAngle, gantryAngle, isocenter) is var result && result is null ? null : new AsyncBeam(result, _service);
        public bool AddImagingSetup(VMS.TPS.Common.Model.Types.ExternalBeamMachineParameters machineParameters, VMS.TPS.Common.Model.Types.ImagingBeamSetupParameters setupParameters, VMS.TPS.Common.Model.API.Structure targetStructure) => _inner.AddImagingSetup(machineParameters, setupParameters, targetStructure);
        public IBeam AddMLCArcBeam(VMS.TPS.Common.Model.Types.ExternalBeamMachineParameters machineParameters, float[,] leafPositions, VMS.TPS.Common.Model.Types.VRect<double> jawPositions, double collimatorAngle, double gantryAngle, double gantryStop, VMS.TPS.Common.Model.Types.GantryDirection gantryDirection, double patientSupportAngle, VMS.TPS.Common.Model.Types.VVector isocenter) => _inner.AddMLCArcBeam(machineParameters, leafPositions, jawPositions, collimatorAngle, gantryAngle, gantryStop, gantryDirection, patientSupportAngle, isocenter) is var result && result is null ? null : new AsyncBeam(result, _service);
        public IBeam AddMLCBeam(VMS.TPS.Common.Model.Types.ExternalBeamMachineParameters machineParameters, float[,] leafPositions, VMS.TPS.Common.Model.Types.VRect<double> jawPositions, double collimatorAngle, double gantryAngle, double patientSupportAngle, VMS.TPS.Common.Model.Types.VVector isocenter) => _inner.AddMLCBeam(machineParameters, leafPositions, jawPositions, collimatorAngle, gantryAngle, patientSupportAngle, isocenter) is var result && result is null ? null : new AsyncBeam(result, _service);
        public IBeam AddMLCSetupBeam(VMS.TPS.Common.Model.Types.ExternalBeamMachineParameters machineParameters, float[,] leafPositions, VMS.TPS.Common.Model.Types.VRect<double> jawPositions, double collimatorAngle, double gantryAngle, double patientSupportAngle, VMS.TPS.Common.Model.Types.VVector isocenter) => _inner.AddMLCSetupBeam(machineParameters, leafPositions, jawPositions, collimatorAngle, gantryAngle, patientSupportAngle, isocenter) is var result && result is null ? null : new AsyncBeam(result, _service);
        public IBeam AddMultipleStaticSegmentBeam(VMS.TPS.Common.Model.Types.ExternalBeamMachineParameters machineParameters, System.Collections.Generic.IEnumerable<double> metersetWeights, double collimatorAngle, double gantryAngle, double patientSupportAngle, VMS.TPS.Common.Model.Types.VVector isocenter) => _inner.AddMultipleStaticSegmentBeam(machineParameters, metersetWeights, collimatorAngle, gantryAngle, patientSupportAngle, isocenter) is var result && result is null ? null : new AsyncBeam(result, _service);
        public IBeam AddSetupBeam(VMS.TPS.Common.Model.Types.ExternalBeamMachineParameters machineParameters, VMS.TPS.Common.Model.Types.VRect<double> jawPositions, double collimatorAngle, double gantryAngle, double patientSupportAngle, VMS.TPS.Common.Model.Types.VVector isocenter) => _inner.AddSetupBeam(machineParameters, jawPositions, collimatorAngle, gantryAngle, patientSupportAngle, isocenter) is var result && result is null ? null : new AsyncBeam(result, _service);
        public IBeam AddSlidingWindowBeam(VMS.TPS.Common.Model.Types.ExternalBeamMachineParameters machineParameters, System.Collections.Generic.IEnumerable<double> metersetWeights, double collimatorAngle, double gantryAngle, double patientSupportAngle, VMS.TPS.Common.Model.Types.VVector isocenter) => _inner.AddSlidingWindowBeam(machineParameters, metersetWeights, collimatorAngle, gantryAngle, patientSupportAngle, isocenter) is var result && result is null ? null : new AsyncBeam(result, _service);
        public IBeam AddSlidingWindowBeamForFixedJaws(VMS.TPS.Common.Model.Types.ExternalBeamMachineParameters machineParameters, System.Collections.Generic.IEnumerable<double> metersetWeights, double collimatorAngle, double gantryAngle, double patientSupportAngle, VMS.TPS.Common.Model.Types.VVector isocenter) => _inner.AddSlidingWindowBeamForFixedJaws(machineParameters, metersetWeights, collimatorAngle, gantryAngle, patientSupportAngle, isocenter) is var result && result is null ? null : new AsyncBeam(result, _service);
        public IBeam AddStaticBeam(VMS.TPS.Common.Model.Types.ExternalBeamMachineParameters machineParameters, VMS.TPS.Common.Model.Types.VRect<double> jawPositions, double collimatorAngle, double gantryAngle, double patientSupportAngle, VMS.TPS.Common.Model.Types.VVector isocenter) => _inner.AddStaticBeam(machineParameters, jawPositions, collimatorAngle, gantryAngle, patientSupportAngle, isocenter) is var result && result is null ? null : new AsyncBeam(result, _service);
        public IBeam AddVMATBeam(VMS.TPS.Common.Model.Types.ExternalBeamMachineParameters machineParameters, System.Collections.Generic.IEnumerable<double> metersetWeights, double collimatorAngle, double gantryAngle, double gantryStop, VMS.TPS.Common.Model.Types.GantryDirection gantryDirection, double patientSupportAngle, VMS.TPS.Common.Model.Types.VVector isocenter) => _inner.AddVMATBeam(machineParameters, metersetWeights, collimatorAngle, gantryAngle, gantryStop, gantryDirection, patientSupportAngle, isocenter) is var result && result is null ? null : new AsyncBeam(result, _service);
        public IBeam AddVMATBeamForFixedJaws(VMS.TPS.Common.Model.Types.ExternalBeamMachineParameters machineParameters, System.Collections.Generic.IEnumerable<double> metersetWeights, double collimatorAngle, double gantryStartAngle, double gantryStopAngle, VMS.TPS.Common.Model.Types.GantryDirection gantryDir, double patientSupportAngle, VMS.TPS.Common.Model.Types.VVector isocenter) => _inner.AddVMATBeamForFixedJaws(machineParameters, metersetWeights, collimatorAngle, gantryStartAngle, gantryStopAngle, gantryDir, patientSupportAngle, isocenter) is var result && result is null ? null : new AsyncBeam(result, _service);
        public IEvaluationDose CopyEvaluationDose(VMS.TPS.Common.Model.API.Dose existing) => _inner.CopyEvaluationDose(existing) is var result && result is null ? null : new AsyncEvaluationDose(result, _service);
        public IEvaluationDose CreateEvaluationDose() => _inner.CreateEvaluationDose() is var result && result is null ? null : new AsyncEvaluationDose(result, _service);
        public void RemoveBeam(VMS.TPS.Common.Model.API.Beam beam) => _inner.RemoveBeam(beam);
        public ITradeoffExplorationContext TradeoffExplorationContext => _inner.TradeoffExplorationContext is null ? null : new AsyncTradeoffExplorationContext(_inner.TradeoffExplorationContext, _service);

        public IEvaluationDose DoseAsEvaluationDose => _inner.DoseAsEvaluationDose is null ? null : new AsyncEvaluationDose(_inner.DoseAsEvaluationDose, _service);

    }
}
